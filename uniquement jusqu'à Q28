#!/bin/env python3
# -*- coding: utf-8 -*-
"""
-----------------------------------------------------------------------------
i11_XXXX_YYYY_projet.py : CR projet ¬´ scrabble ¬ª, groupe ZZZ

XXXX <prenom.nom@etu-univ-grenoble-alpes.fr>
YYYY <prenom.nom@univ-grenoble-alpes.fr>
-----------------------------------------------------------------------------
"""

# IMPORTS ######################################################################

import random             # N√©cessaire pour les fonctions de hasard (randint)
# from collections import Counter # Remplac√© par dictionnaire manuel


# CONSTANTES ###################################################################

TAILLE_PLATEAU = 15     # taille du plateau de jeu

JOKER = '?'             # symbole du joker
FICHIER_DICO_FR = 'littre.txt'      # Fichier des mots fran√ßais
FICHIER_DICO_JETONS = 'lettres.txt' # Fichier des jetons, valeurs et occurrences

# ‚ö† pas de variable globales, sauf cas exceptionnel


# FONCTIONS UTILITAIRES ACADEMIQUES ############################################

def convert_str_maj_epspace(chaine):
    """
    Convertit la cha√Æne en majuscules et retire les espaces/retours √† la ligne manuellement.
    (Simule .strip().upper() sans utiliser ces m√©thodes non autoris√©es).
    """
    res = ""
    i = 0
    # Suppression des espaces de t√™te
    while i < len(chaine) and chaine[i] == ' ':
        i += 1
        
    # Conversion et construction du corps
    while i < len(chaine):
        car = chaine[i]
        
        if 'a' <= car <= 'z':
            car = chr(ord(car) - 32)
        if car != '\n' and car != '\r':
            res += car
            
        i += 1
    
    # Suppression des espaces de queue
    while len(res) > 0 and res[-1] == ' ':
        res = res[:-1]
        
    return res

# PARTIE 1 : LE PLATEAU (Q1 √† Q4) ##############################################

def symetrise_liste(lst):
    """Auxilliaire pour Q1) : sym√©trise en place la liste lst."""
    copie_lst = list(lst)
    for i in range(2, len(copie_lst)+1) : 
        lst.append(copie_lst[-i])

def init_bonus():
    """Q1. Initialise la grille des bonus (format officiel du sujet)."""
    plt_bonus = [
        ['MT', ''  , ''  , 'LD', ''  , ''  , ''  , 'MT'],
        [''  , 'MD', ''  , ''  , ''  , 'LT', ''  , ''  ],
        [''  , ''  , 'MD', ''  , ''  , ''  , 'LD', ''  ],
        ['LD', ''  , ''  , 'MD', ''  , ''  , ''  , 'LD'],
        [''  , ''  , ''  , ''  , 'MD', ''  , ''  , ''  ],
        [''  , 'LT', ''  , ''  , ''  , 'LT', ''  , ''  ],
        [''  , ''  , 'LD', ''  , ''  , ''  , 'LD', ''  ],
        ['MT', ''  , ''  , 'LD', ''  , ''  , ''  , 'MD']
    ]
    r = 0
    while r < len(plt_bonus):
        symetrise_liste(plt_bonus[r])
        r += 1
    symetrise_liste(plt_bonus)   # sym√©trie verticale
    return plt_bonus

def init_jetons():
    """Q2. Cr√©e une grille 15x15 de cha√Ænes vides. Chaque ligne est ind√©pendante."""
    jetons = []
    i = 0
    while i < TAILLE_PLATEAU:
        ligne = []
        j = 0
        while j < TAILLE_PLATEAU:
            ligne.append('')
            j += 1
        jetons.append(ligne)
        i += 1
    return jetons

def affiche_jetons(jetons):
    n = len(jetons)

    # En-t√™te colonnes (3 caract√®res par colonne : "01 ")
    print("    ", end="")
    j = 0
    while j < n:
        col = j + 1
        if col < 10:
            print("0" + str(col) + "  ", end="")   # "01 "
        else:
            print(str(col) + "  ", end="")         # "10 "
        j += 1
    print()

    # Ligne de s√©paration : |--- pour chaque colonne
    print("   ", end="")
    j = 0
    while j < n:
        print("|---", end="")
        j += 1
    print("|")

    # Lignes du plateau
    i = 0
    while i < n:
        lig = i + 1
        if lig < 10:
            print("0" + str(lig) + " ", end="")
        else:
            print(str(lig) + " ", end="")

        j = 0
        while j < n:
            c = jetons[i][j]
            if c == "":
                print("|   ", end="")       # 3 espaces de largeur
            else:
                print("| " + c[0] + " ", end="")
            j += 1
        print("|")

        print("   ", end="")
        j = 0
        while j < n:
            print("|---", end="")
            j += 1
        print("|")
        i += 1

def affiche_jetons_avec_bonus(jetons, bonus):
    n = len(jetons)

    # En-t√™te colonnes (4 caract√®res par colonne : "01  ")
    print("     ", end="")
    j = 0
    while j < n:
        col = j + 1
        if col < 10:
            print("0" + str(col) + "   ", end="")   # "01  "
        else:
            print(str(col) + "   ", end="")         # "10  "
        j += 1
    print()

    # S√©parateur : |---- pour chaque colonne
    print("   ", end="")
    j = 0
    while j < n:
        print("|----", end="")
        j += 1
    print("|")

    # Lignes
    i = 0
    while i < n:
        lig = i + 1
        if lig < 10:
            print("0" + str(lig) + " ", end="")
        else:
            print(str(lig) + " ", end="")

        j = 0
        while j < n:
            lettre = jetons[i][j]
            b = bonus[i][j]
            sym = ' '
            if b == 'MD':
                sym = '*'
            elif b == 'MT':
                sym = '#'
            elif b == 'LD':
                sym = '+'
            elif b == 'LT':
                sym = '='

            if lettre == "":
                print("|  " + sym + " ", end="")        # "  * "
            else:
                print("| " + lettre[0] + sym + " ", end="")  # " A* "
            j += 1
        print("|")

        print("   ", end="")
        j = 0
        while j < n:
            print("|----", end="")
            j += 1
        print("|")
        i += 1
        
# PARTIE 2 : PIOCHE ############################################################

def piocher(x, sac):
    """
    Q8) Pioche x jetons au hasard dans sac. Modifie sac et retourne la liste pioch√©e.
    Remplacement de random.sample par random.randint et del pour la conformit√©.
    """
    nb = min(x, len(sac))
    jetons_pioches = []
    
    i = 0
    while i < nb:
        if len(sac) > 0:
            # random.randint(a, b) inclut b
            index_aleatoire = random.randint(0, len(sac) - 1) 
            
            jeton = sac[index_aleatoire]
            jetons_pioches.append(jeton)
            
            # Utilisation de del maliste[index] (m√©thode de suppression list√©e dans le poly)
            del sac[index_aleatoire] 
            
        i += 1
        
    return jetons_pioches

def completer_main(main, sac):
    """
    Q9) Compl√®te la main √† 7 jetons (effets de bord).
    Remplacement de list.extend par une boucle for/append.
    """
    nb_manquant = 7 - len(main)
    if nb_manquant > 0:
        nouveaux = piocher(nb_manquant, sac)
        # Remplacement de main.extend(nouveaux) par for/append
        for jeton in nouveaux:
            main.append(jeton) 

def echanger(jetons_a_echanger, main, sac):
    """
    Q10) √âchange les jetons list√©s depuis la main avec le sac.
    Utilisation de dictionnaire manuel pour remplacer collections.Counter.
    """
    if len(sac) < len(jetons_a_echanger):
        return False
        
    # Remplacement de Counter par dictionnaire manuel
    compteur_main = {}
    for jeton in main:
        if jeton in compteur_main:
            compteur_main[jeton] += 1
        else:
            compteur_main[jeton] = 1

    compteur_requis = {}
    for jeton in jetons_a_echanger:
        if jeton in compteur_requis:
            compteur_requis[jeton] += 1
        else:
            compteur_requis[jeton] = 1
        
    # 1. V√©rification que la main contient toutes les lettres requises
    for jeton in compteur_requis: 
        if jeton not in compteur_main or compteur_main[jeton] < compteur_requis[jeton]:
            return False 

    # 2. D√©fausse et √©change
    
    # Mettre √† jour le compteur de la main
    for jeton in jetons_a_echanger:
        compteur_main[jeton] -= 1

    # Reconstruire la main mise √† jour
    main_mise_a_jour = []
    for jeton, count in compteur_main.items():
        i = 0
        while i < count:
            main_mise_a_jour.append(jeton)
            i += 1
            
    # Modification par effet de bord
    main[:] = main_mise_a_jour

    # Ajout des jetons √©chang√©s au sac
    for jeton in jetons_a_echanger:
        sac.append(jeton)
        
    # Piocher les nouveaux jetons
    nouveaux = piocher(len(jetons_a_echanger), sac)
    for jeton in nouveaux:
        main.append(jeton)
    
    return True

# PARTIE 3 : CONSTRUCTIONS DE MOTS #############################################

def generer_dictfr(nf=FICHIER_DICO_FR) :
    """
    Q12) Liste des mots Fran√ßais en majuscules sans accent.
    Utilisation de open() natif et nettoyage manuel de chaque ligne.
    """
    mots = []
    try:
        with open(nf, 'r', encoding='utf_8') as fich_mots :
            for line in fich_mots :
                # Nettoyage et conversion en majuscules manuelle (conformit√© stricte)
                res = convert_str_maj_epspace(line)
                if len(res) > 0:
                    mots.append(res)
                    
        print("INFO: ", len(mots), " mots charg√©s depuis ", nf, ".")
    except FileNotFoundError:
        temp_dico_name = 'littre (1).txt'
        try:
            with open(temp_dico_name, 'r', encoding='utf_8') as fich_mots :
                for line in fich_mots :
                    res = convert_str_maj_epspace(line)
                    if len(res) > 0:
                        mots.append(res)
            print("INFO: ", len(mots), " mots charg√©s depuis ", temp_dico_name, ".")
        except FileNotFoundError:
            print("ERREUR CRITIQUE: Le fichier dictionnaire '", nf, "' (ni son alternative) est introuvable. Les mots jouables seront limit√©s.")
        except Exception as e:
            print("ERREUR lors du chargement de ", temp_dico_name, ": ", e)
    except Exception as e:
        print("ERREUR lors du chargement de ", nf, ": ", e)
        
    return mots

def select_mot_initiale(motsfr, let):
    """
    Q13) Tous les mots commen√ßant par let.
    Remplacement de .startswith par l'indexation [0] (conforme).
    """
    res = []
    for mot in motsfr:
        if len(mot) > 0 and mot[0] == let:
            res.append(mot)
    return res

def select_mot_longueur(motsfr, lgr):
    """Q14) Tous les mots de longueur lgr."""
    return [mot for mot in motsfr if len(mot) == lgr]

def mot_jouable(mot, ll):
    """
    Q15/Q17) Vrai si mot peut √™tre √©crit avec les lettres de ll (joker '?').
    Remplacement de collections.Counter par dictionnaire manuel.
    """
    # Remplacement de Counter(ll) par un dictionnaire manuel
    dispo = {}
    for jeton in ll:
        if jeton in dispo:
            dispo[jeton] += 1
        else:
            dispo[jeton] = 1
        
    for ch in mot:
        if ch in dispo and dispo[ch] > 0:
            dispo[ch] -= 1
        elif JOKER in dispo and dispo[JOKER] > 0:
            dispo[JOKER] -= 1
        else:
            return False
            
    return True

def mots_jouables(motsfr, ll):
    """Q16/Q17) Tous les mots jouables avec ll."""
    return [mot for mot in motsfr if mot_jouable(mot, ll)]


# PARTIE 4 : DICO JETONS, PIOCHE & SCORE ##########################################

def generer_dico(nf=FICHIER_DICO_JETONS):
    """
    Q19) Dictionnaire des jetons (lettres.txt).
    Parsing manuel sans .split().
    """
    jetons = {}
    try:
        with open(nf, 'r', encoding='utf_8') as lettres:
            for ligne in lettres:
                # La logique de nettoyage est int√©gr√©e ici pour le fichier
                ligne_nouvelle = convert_str_maj_epspace(ligne)
                if not ligne_nouvelle: continue 

                # Parsing manuel (Remplacement de .split(';'))
                parties = []
                last_index = 0
                
                i = 0
                while i < len(ligne_nouvelle):
                    if ligne_nouvelle[i] == ';':
                        partie_brut = ""
                        j = last_index
                        while j < i:
                            partie_brut += ligne_nouvelle[j]
                            j += 1
                        # Nettoyage de la partie
                        parties.append(convert_str_maj_epspace(partie_brut)) 
                        last_index = i + 1
                    i += 1
                
                # Ajouter la derni√®re partie
                partie_brut = ""
                j = last_index
                while j < len(ligne_nouvelle):
                    partie_brut += ligne_nouvelle[j]
                    j += 1
                parties.append(convert_str_maj_epspace(partie_brut))

                # Traitement des parties
                if len(parties) == 3:
                    l = parties[0]
                    v = int(parties[1])
                    o = int(parties[2])
                    jetons[l] = {'occ': o, 'val': v}
                    
        print("INFO: Dictionnaire de jetons charg√© depuis ", nf, ".")
    except FileNotFoundError:
        print("ERREUR CRITIQUE: Le fichier des jetons '", nf, "' est introuvable. Impossible d'initialiser la partie.")
    except Exception as e:
        print("ERREUR lors du chargement de ", nf, ": ", e)
        
    return jetons

def init_pioche(dico):
    """Q20) Construit la pioche officielle √† partir du dico (occurrences)."""
    sac = []
    for lettre, donnees in dico.items():
        # Utilisation d'une boucle while au lieu de .extend
        i = 0
        while i < donnees['occ']:
            sac.append(lettre)
            i += 1
        
    random.shuffle(sac) 
    return sac

def valeur_mot(mot, dico):
    """Q22) Somme des valeurs + bonus Scrabble (50 pts si 7 lettres)."""
    total = 0
    for ch in mot:
        # Structure conforme if/in/crochets
        if ch in dico:
            total += dico[ch]['val']
        else:
            total += 0
    
    if len(mot) == 7:
        total += 50
    return total

def meilleur_mot(motsfr, ll, dico):
    """Q23) Meilleur mot jouable selon valeur_mot ; "" si aucun."""
    meilleur_score = -1
    meilleur = ""
    
    for mot in motsfr:
        if mot_jouable(mot, ll):
            sc = valeur_mot(mot, dico)
            if sc > meilleur_score:
                meilleur_score = sc
                meilleur = mot
                
    return meilleur

def meilleurs_mots(motsfr, ll, dico):
    """Q24) Tous les meilleurs mots (ex aequo). [] si aucun."""
    res = []
    meilleur_score = -1
    
    for mot in motsfr:
        if mot_jouable(mot, ll):
            sc = valeur_mot(mot, dico)
            if sc > meilleur_score:
                meilleur_score = sc
                res = [mot] 
            elif sc == meilleur_score:
                res.append(mot) 
                
    return res if meilleur_score >= 0 else []


# PARTIE 5 : GESTION DU JEU TEXTE (Q25 √† Q28) ##################################

def consommateur_de_lettres(mot, main):
    """
    Q23 (utilitaire) : Retire dupliqu√©es les lettres du mot depuis la main (utilise '?').
    Remplacement de collections.Counter par dictionnaire manuel.
    """
    
    # Cr√©ation du compteur manuel
    compteur_tmp = {}
    for jeton in main:
        if jeton in compteur_tmp:
            compteur_tmp[jeton] += 1
        else:
            compteur_tmp[jeton] = 1
    
    # 1. V√©rification si jouable (simulation de la consommation)
    verif_compteur = dict(compteur_tmp) 
    
    for ch in mot:
        if ch in verif_compteur and verif_compteur[ch] > 0:
            verif_compteur[ch] -= 1
        elif JOKER in verif_compteur and verif_compteur[JOKER] > 0:
            verif_compteur[JOKER] -= 1
        else:
            return False 

    # 2. Modification de la main
    main_mise_a_jour = []
    
    # Soustraire les jetons utilis√©s
    compteur_a_conserver = dict(compteur_tmp)
    for ch in mot:
        if ch in compteur_a_conserver and compteur_a_conserver[ch] > 0:
            compteur_a_conserver[ch] -= 1
        elif JOKER in compteur_a_conserver and compteur_a_conserver[JOKER] > 0:
            compteur_a_conserver[JOKER] -= 1
            
    # Reconstruire la main
    for jeton, count in compteur_a_conserver.items():
        i = 0
        while i < count:
            main_mise_a_jour.append(jeton)
            i += 1
            
    # Modification par effet de bord (main[:] = ...)
    main[:] = main_mise_a_jour
    return True

def detection_fin(main, sac):
    """Q26) True si le joueur DOIT piocher mais le sac est insuffisant."""
    manque = 7 - len(main)
    return manque > 0 and len(sac) < manque

def afficher_main(main):
    """Affichage auxiliaire de la main."""
    print("Main:", main, "(taille:", len(main), ")")

def prochain_joueur_index(idx, nb):
    """Q27) Indice du joueur suivant (tour circulaire)."""
    return (idx + 1) % nb

def malus_main(main, dico):
    """
    Q27) Somme des valeurs r√©siduelles (p√©nalit√© fin de partie).
    Remplacement de dico.get(...) par la structure if/in/crochets conforme.
    """
    total = 0
    for ch in main:
        if ch in dico:
            total += dico[ch]['val']
        else:
            total += 0
    return total

def tour_joueur(nom, main, sac, motsfr, dico, jetons, bonus):
    """
    Q25) G√®re un tour de joueur (mode SANS placement).
    Affiche le plateau (Q4) mais ne permet pas d'y jouer.
    """
    print("\n===== Tour de", nom, "=====")
    # --- AFFICHAGE PLATEAU AJOUT√â (CORRECTION) ---
    affiche_jetons_avec_bonus(jetons, bonus)
    # ---------------------------------------------
    afficher_main(main)

    # Choix (P)asser / (E)changer / proposer un (M)ot
    print("Choix : [P]asser / [E]changer / proposer un [M]ot")
    choix_input_brut = input("Votre choix (P/E/M) : ")
    choix = convert_str_maj_epspace(choix_input_brut)
    
    while choix not in ["P", "E", "M"]:
        choix_input_brut = input("Votre choix (P/E/M) : ")
        choix = convert_str_maj_epspace(choix_input_brut)

    # Passer (P)
    if choix == "P":
        print("->", nom, "passe son tour.")
        return 0, False

    # √âchanger (E)
    if choix == "E":
        if len(sac) == 0:
            print("-> Sac vide : √©change impossible.")
            return 0, False
        
        s = input("Liste des lettres √† √©changer (sans s√©parateur, ex: AEI) : ")
        to_swap_str = convert_str_maj_epspace(s)
        to_swap = list(to_swap_str)

        ok = echanger(to_swap, main, sac)
        if ok:
            print("√âchange r√©ussi.")
            afficher_main(main)
        else:
            print("√âchange impossible (lettre(s) absente(s) ou sac insuffisant).")
        return 0, False

    # Proposer un mot (M)
    if choix == "M":
        mot_input_brut = input("Mot propos√© (majuscules, sans accents) : ")
        mot = convert_str_maj_epspace(mot_input_brut)

        # 1) v√©rifier qu'il est dans le dictionnaire fran√ßais
        if mot not in motsfr:
            print("Mot non autoris√© (absent du dictionnaire).")
            return 0, False

        # 2) jouable avec la main ?
        if not mot_jouable(mot, main):
            print("Mot non jouable avec votre main.")
            return 0, False

        # 3) valeur (Q22)
        val = valeur_mot(mot, dico)
        print("Valeur du mot:", mot, "=", val, "points")

        # d√©fausser les lettres correspondantes (Q23)
        consommateur_de_lettres(mot, main)

        # D√©tection de la fin de partie (Q26)
        if detection_fin(main, sac):
            print("Fin de partie: sac insuffisant pour compl√©ter la main. Partie termin√©e.")
            return val, True

        # sinon re-piocher pour revenir √† 7 (Q9)
        completer_main(main, sac)
        afficher_main(main)
        return val, False

    return 0, False


# PARTIE 7 : BONUS ET AM√âLIORATIONS ############################################

def meilleure_aide_de_jeu(motsfr, main, dico):
    """
    Bonus Q23 (Aide de jeu): Proposer le meilleur mot jouable avec les lettres en main.
    """
    meilleurs = meilleurs_mots(motsfr, main, dico)
    
    if not meilleurs:
        print("Aide de jeu : Aucun mot jouable avec les lettres dans votre main.")
        return
        
    meilleur_score = valeur_mot(meilleurs[0], dico)
    
    print("\n--- Aide de jeu : Meilleurs mots jouables avec la main ---")
    print("Score maximum possible:", meilleur_score, "points.")
    print("Mots trouv√©s (ex aequo):", meilleurs)


# PROGRAMME PRINCIPAL (OBJECTIF Q28) ###########################################

if __name__ == '__main__':
    
    # --- Chargement et Initialisation (Q12, Q19) ---
    dico = generer_dico()
    motsfr = generer_dictfr(FICHIER_DICO_FR)
    
    if not dico or not motsfr:
        print("\n*** Impossible de d√©marrer la partie sans les ressources (dictionnaires de mots et de jetons). ***")
    else:
        sac = init_pioche(dico) 
        
        # --- INITIALISATION PLATEAU (POUR AFFICHAGE Q4) ---
        jetons = init_jetons()
        bonus = init_bonus()
        
        print("\n==============================================")
        print("============== D√âBUT DE LA PARTIE =============")
        print("==============================================\n")

        # --- Initialisation des joueurs ---
        try:
            nb_j_input = input("Nombre de joueurs (>=1) ? ")
            nb_j_nettoye = convert_str_maj_epspace(nb_j_input)
            nb_j = int(nb_j_nettoye)
            while nb_j < 1:
                nb_j_input = input("Nombre de joueurs doit √™tre >= 1. R√©essayez : ")
                nb_j_nettoye = convert_str_maj_epspace(nb_j_input)
                nb_j = int(nb_j_nettoye)
        except:
            nb_j = 1
            print("Nombre de joueurs par d√©faut: ", 1) 

        joueurs = []
        n = 0
        while n < nb_j:
            nom_prompt = "Nom du joueur " + str(n+1) + " : "
            nom_input = input(nom_prompt)
            nom = convert_str_maj_epspace(nom_input)
            
            if nom == "":
                nom = "J" + str(n+1)
            
            joueurs.append({"nom": nom, "score": 0, "main": []})
            n += 1

        for j in joueurs:
            j["main"] = piocher(7, sac) # Q21

        # --- Boucle de jeu (Q28) ---
        joueur_courant = 0
        fin = False
        
        while not fin:
            j = joueurs[joueur_courant]
            
            # --- Bonus de la Partie 7 (Aide de jeu) ---
            aide_input = input("\nSouhaitez-vous une aide de jeu (Y/N) ? ")
            if convert_str_maj_epspace(aide_input) == 'Y':
                meilleure_aide_de_jeu(motsfr, j["main"], dico)
            # ---------------------------------------------------

            print("\n-------------------------------")
            print("Scores actuels :")
            for joueur in joueurs:
                print(" - ", joueur['nom'], ":", joueur['score'])

            # Tour de jeu SIMPLIFI√â (Q25), en passant les jetons et bonus pour affichage
            delta, fin = tour_joueur(j["nom"], j["main"], sac, motsfr, dico, jetons, bonus)
            j["score"] += delta

            # Gestion de la fin de partie (Q26, Q28)
            if fin:
                print("\n=== Fin de partie (sac vide ou insuffisant) ===")
                for t, joueur in enumerate(joueurs):
                    if t != joueur_courant:
                        mal = malus_main(joueur["main"], dico) # Q27
                        joueur["score"] -= mal
                        print(joueur['nom'], " perd ", mal, " points (lettres restantes)")
                
                fin = True # Sortie de la boucle while

            joueur_courant = prochain_joueur_index(joueur_courant, nb_j)

        # --- R√©sultats finaux (Q28) ---
        print("\n=== Scores finaux ===")
        meilleur_nom = ""
        meilleur_sc = -999999
        
        for joueur in joueurs:
            print(joueur['nom'], ":", joueur['score'])
            if joueur["score"] > meilleur_sc:
                meilleur_sc = joueur["score"]
                meilleur_nom = joueur["nom"]
        
        print("\nüèÜ Gagnant :", meilleur_nom, "avec", meilleur_sc, "points.")
        
        s = input("Liste des lettres √† √©changer (sans s√©parateur, ex: AEI) : ")
        to_swap_str = nettoyer_chaine_manuel(s)
        to_swap = list(to_swap_str)

        ok = echanger(to_swap, main, sac)
        if ok:
            print("√âchange r√©ussi.")
            afficher_main(main)
        else:
            print("√âchange impossible (lettre(s) absente(s) ou sac insuffisant).")
        return 0, False

    # Proposer un mot (M)
    if choix == "M":
        mot_input_brut = input("Mot propos√© (majuscules, sans accents) : ")
        mot = nettoyer_chaine_manuel(mot_input_brut)

        # 1) v√©rifier qu'il est dans le dictionnaire fran√ßais
        if mot not in motsfr:
            print("Mot non autoris√© (absent du dictionnaire).")
            return 0, False

        # 2) jouable avec la main ?
        if not mot_jouable(mot, main):
            print("Mot non jouable avec votre main.")
            return 0, False

        # 3) valeur (Q22)
        val = valeur_mot(mot, dico)
        print("Valeur du mot:", mot, "=", val, "points")

        # d√©fausser les lettres correspondantes (Q23)
        consommateur_de_lettres(mot, main)

        # D√©tection de la fin de partie (Q26)
        if a_plus_assez_pour_completer(main, sac):
            print("Fin de partie: sac insuffisant pour compl√©ter la main. Partie termin√©e.")
            return val, True

        # sinon re-piocher pour revenir √† 7 (Q9)
        completer_main(main, sac)
        afficher_main(main)
        return val, False

    return 0, False


# PROGRAMME PRINCIPAL (OBJECTIF Q28) ###########################################

if __name__ == '__main__':
    
    # --- Chargement et Initialisation (Q12, Q19) ---
    dico = generer_dico()
    motsfr = generer_dictfr(FICHIER_DICO_FR)
    
    if not dico or not motsfr:
        print("\n*** Impossible de d√©marrer la partie sans les ressources (dictionnaires de mots et de jetons). ***")
    else:
        sac = init_pioche(dico) 
        
        print("\n==============================================")
        print("=== D√âBUT DE LA PARTIE SIMUL√âE (JEU SIMPLIFI√â) ===")
        print("==============================================\n")

        # --- Initialisation des joueurs ---
        try:
            nb_j_input = input("Nombre de joueurs (>=1) ? ")
            nb_j_nettoye = nettoyer_chaine_manuel(nb_j_input)
            nb_j = int(nb_j_nettoye)
            while nb_j < 1:
                nb_j_input = input("Nombre de joueurs doit √™tre >= 1. R√©essayez : ")
                nb_j_nettoye = nettoyer_chaine_manuel(nb_j_input)
                nb_j = int(nb_j_nettoye)
        except:
            nb_j = 1
            print("Nombre de joueurs par d√©faut: ", 1) 

        joueurs = []
        n = 0
        while n < nb_j:
            nom_prompt = "Nom du joueur " + str(n+1) + " : "
            nom_input = input(nom_prompt)
            nom = nettoyer_chaine_manuel(nom_input)
            
            if nom == "":
                nom = "J" + str(n+1)
            
            joueurs.append({"nom": nom, "score": 0, "main": []})
            n += 1

        for j in joueurs:
            j["main"] = piocher(7, sac) # Q21

        # --- Boucle de jeu (Q28) ---
        joueur_courant = 0
        fin = False
        
        while not fin:
            j = joueurs[joueur_courant]
            
            print("\n-------------------------------")
            print("Scores actuels :")
            for joueur in joueurs:
                print(" - ", joueur['nom'], ":", joueur['score'])

            # Tour de jeu SIMPLIFI√â (Q25)
            delta, fin = tour_joueur(j["nom"], j["main"], sac, motsfr, dico)
            j["score"] += delta

            # Gestion de la fin de partie (Q26, Q28)
            if fin:
                print("\n=== Fin de partie (sac vide ou insuffisant) ===")
                for t, joueur in enumerate(joueurs):
                    if t != joueur_courant:
                        mal = malus_main(joueur["main"], dico) # Q27
                        joueur["score"] -= mal
                        print(joueur['nom'], " perd ", mal, " points (lettres restantes)")
                
                fin = True # Sortie de la boucle while

            joueur_courant = prochain_joueur_index(joueur_courant, nb_j)

        # --- R√©sultats finaux (Q28) ---
        print("\n=== Scores finaux ===")
        meilleur_nom = ""
        meilleur_sc = -999999
        
        for joueur in joueurs:
            print(joueur['nom'], ":", joueur['score'])
            if joueur["score"] > meilleur_sc:
                meilleur_sc = joueur["score"]
                meilleur_nom = joueur["nom"]
        
        print("\nüèÜ Gagnant :", meilleur_nom, "avec", meilleur_sc, "points.")
